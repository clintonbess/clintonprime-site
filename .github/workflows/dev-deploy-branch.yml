name: Deploy (Dev) â€” Server-Side Build (EC2 via SSM)

on:
  push:
    branches: ["dev-deploy"]
  workflow_dispatch:

permissions:
  id-token: write # OIDC
  contents: read

concurrency:
  group: deploy-dev-ec2
  cancel-in-progress: true

# Runner-side env that we write into scripts/env.server on the EC2 box.
env:
  WEB_ROOT: /var/www/html/clintonprime
  SITE_ROOT: /opt/clintonprime-site
  REPO_DIR: /opt/clintonprime-site/repo
  CURRENT_API: /opt/clintonprime-site/current-api
  PM2_NAME: clintonprime-api-dev
  DOMAIN: dev.clintonprime.com
  EMAIL: clintonbess3@gmail.com
  DEPLOY_USER: ubuntu

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: dev

    steps:
      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Who am I?
        run: aws sts get-caller-identity

      # If your OIDC role includes ec2:DescribeInstances, keep this.
      # Otherwise you can skip this and use SSM tag-targeting directly (see notes below).
      - name: Find EC2 instance by tag (Name=clintonprime-dev)
        id: ec2
        run: |
          IID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=clintonprime-dev" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].InstanceId" --output text)
          [ -n "$IID" ] || { echo "No instance found"; exit 1; }
          echo "id=$IID" >> "$GITHUB_OUTPUT"
          echo "InstanceId: $IID"

      - name: Send deploy via SSM (base64 remote script; run as ubuntu)
        id: ssm
        run: |
          set -euo pipefail

          # Build the remote script with variables expanded here on the runner.
          REMOTE_SCRIPT=$(cat <<'EOS'
          set -euo pipefail

          export DEPLOY_USER="${DEPLOY_USER}"
          export WEB_ROOT="${WEB_ROOT}"
          export SITE_ROOT="${SITE_ROOT}"
          export REPO_DIR="${REPO_DIR}"
          export CURRENT_API="${CURRENT_API}"
          export PM2_NAME="${PM2_NAME}"
          export DOMAIN="${DOMAIN}"
          export EMAIL="${EMAIL}"
          export GIT_REPO_URL="git@github.com:clintonbess/clintonprime-site.git"
          export GITHUB_SHA="${GITHUB_SHA}"
          export GITHUB_REF_NAME="${GITHUB_REF_NAME}"

          # Prepare directories and ownership
          sudo mkdir -p "${SITE_ROOT}"
          sudo mkdir -p "${REPO_DIR}"
          sudo chown -R "${DEPLOY_USER}:${DEPLOY_USER}" "${SITE_ROOT}"

          # Mark repo as safe for both root (SSM) and ubuntu (actual deploy user)
          sudo git config --system --add safe.directory "${REPO_DIR}" || true
          sudo -u "${DEPLOY_USER}" git config --global --add safe.directory "${REPO_DIR}" || true

          # Clone or fetch repo, then checkout exact SHA
          if [ -d "${REPO_DIR}/.git" ]; then
            sudo -u "${DEPLOY_USER}" bash -lc "git -C '${REPO_DIR}' fetch --all --tags"
          else
            sudo -u "${DEPLOY_USER}" bash -lc "git clone '${GIT_REPO_URL}' '${REPO_DIR}'"
          fi

          sudo -u "${DEPLOY_USER}" bash -lc "
            cd '${REPO_DIR}' && \
            git config core.fileMode false || true && \
            git reset --hard HEAD && \
            git clean -fd && \
            git checkout -q '${GITHUB_SHA}' && \
            chmod +x scripts/*.sh || true
          "

          # Render scripts/env.server
          sudo tee "${REPO_DIR}/scripts/env.server" >/dev/null <<ENVV
          REMOTE_USER=${DEPLOY_USER}
          WEB_ROOT=${WEB_ROOT}
          SITE_ROOT=${SITE_ROOT}
          REPO_DIR=${REPO_DIR}
          CURRENT_API=${CURRENT_API}
          PM2_NAME=${PM2_NAME}
          REPO_URL=${GIT_REPO_URL}
          BRANCH=
          SHA=${GITHUB_SHA}

          # API runtime env (fill from GH secrets at send time below)
          API_PORT=${API_PORT}
          SPOTIFY_CLIENT_ID=${SPOTIFY_CLIENT_ID}
          SPOTIFY_CLIENT_SECRET=${SPOTIFY_CLIENT_SECRET}
          SPOTIFY_REDIRECT_URI=${SPOTIFY_REDIRECT_URI}
          SPOTIFY_REFRESH_TOKEN=${SPOTIFY_REFRESH_TOKEN}
          SPOTIFY_ACCESS_TOKEN=${SPOTIFY_ACCESS_TOKEN}
          ENVV
          sudo chown "${DEPLOY_USER}:${DEPLOY_USER}" "${REPO_DIR}/scripts/env.server"
          sudo chmod 600 "${REPO_DIR}/scripts/env.server" || true

          echo "[CI] kicking deploy for ${GITHUB_SHA} on branch ${GITHUB_REF_NAME}"

          # Run the unified deploy AS ubuntu (login shell for PATH/npm etc.)
          sudo -u "${DEPLOY_USER}" env HOME="/home/${DEPLOY_USER}" \
            bash -lc "cd '${REPO_DIR}' && BRANCH='origin/${GITHUB_REF_NAME}' SHA='${GITHUB_SHA}' bash scripts/deploy.sh"
          EOS
          )

          # Expand *secrets* into the script at send-time (not stored in repo)
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{API_PORT\}/${{ secrets.API_PORT || '3000' }}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{SPOTIFY_CLIENT_ID\}/${{ secrets.SPOTIFY_CLIENT_ID }}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{SPOTIFY_CLIENT_SECRET\}/${{ secrets.SPOTIFY_CLIENT_SECRET }}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{SPOTIFY_REDIRECT_URI\}/${{ secrets.SPOTIFY_REDIRECT_URI || '' }}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{SPOTIFY_REFRESH_TOKEN\}/${{ secrets.SPOTIFY_REFRESH_TOKEN }}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{SPOTIFY_ACCESS_TOKEN\}/${{ secrets.SPOTIFY_ACCESS_TOKEN || '' }}}"

          # Also substitute non-secret envs (so heredoc sees final values)
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{DEPLOY_USER\}/${DEPLOY_USER}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{WEB_ROOT\}/${WEB_ROOT}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{SITE_ROOT\}/${SITE_ROOT}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{REPO_DIR\}/${REPO_DIR}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{CURRENT_API\}/${CURRENT_API}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{PM2_NAME\}/${PM2_NAME}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{DOMAIN\}/${DOMAIN}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{EMAIL\}/${EMAIL}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{GITHUB_SHA\}/${GITHUB_SHA}}"
          REMOTE_SCRIPT="${REMOTE_SCRIPT//\$\{GITHUB_REF_NAME\}/${GITHUB_REF_NAME}}"

          # Base64-encode to avoid AWS CLI --parameters parsing issues
          B64=$(printf '%s' "$REMOTE_SCRIPT" | base64 -w0)

          # Send as a single command that decodes and executes on the instance
          CMD_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.ec2.outputs.id }}" \
            --document-name "AWS-RunShellScript" \
            --parameters '{"commands":["echo '"$B64"' | base64 -d | bash -euo pipefail"]}' \
            --comment "Deploy dev ${GITHUB_SHA}" \
            --query "Command.CommandId" --output text)

          echo "cmd=$CMD_ID" >> "$GITHUB_OUTPUT"
          echo "CommandId: $CMD_ID"

      - name: Wait for completion
        run: |
          set -euo pipefail
          CMD_ID="${{ steps.ssm.outputs.cmd }}"
          IID="${{ steps.ec2.outputs.id }}"
          while true; do
            STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --details \
              --query "CommandInvocations[0].Status" --output text)
            echo "SSM status: $STATUS"
            case "$STATUS" in
              InProgress|Pending|Delayed) sleep 5 ;;
              Success) break ;;
              *) echo "Command failed: $STATUS"
                 aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$IID" || true
                 exit 1 ;;
            esac
          done

      - name: Fetch remote stdout/stderr
        if: always()
        run: |
          aws ssm get-command-invocation \
            --command-id "${{ steps.ssm.outputs.cmd }}" \
            --instance-id "${{ steps.ec2.outputs.id }}" \
            --query '{StdOut:StandardOutputContent,StdErr:StandardErrorContent}' \
            --output text || true
